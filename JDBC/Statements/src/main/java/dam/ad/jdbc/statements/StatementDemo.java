package dam.ad.jdbc.statements;

import java.sql.*;
import java.time.LocalDate;
import java.util.StringJoiner;

public class StatementDemo {

    // URL de conexión a la base de datos futbol HSQLDB
    static final String HSQLDB_FUTBOL_URL =
            "jdbc:hsqldb:C:/BBDDs/hsqldb/futbol;ifexists=true";

    public static void main(String[] args) {
        dropTable("jugador");
        dropTable("equipo");
        createTableEquipo();
        createTableJugador();

        deleteAllJugadores();
        deleteAllEquipos();

        insertEquipo();
        insertJugador();
        insertEquipo(2, "F.C. Barcelona", "ESP");
        insertEquipo("Levante U.D,", "ESP");
        insertEquipo("Club Atlético Newell's Old Boys", "ARG");
        insertJugador(2, "Jude Bellingham", "GBR",
                LocalDate.parse("2003-06-29"), 1.86, 75, 5, 1);
        insertJugador("Pedri", "ESP",
                LocalDate.parse("2002-11-25"), 1.74, 60, 8, 2);

        printAllEquipos();
        printAllJugadores();

        shutdown(); // Apagar la base de datos (cierra el fichero)
    }

    // Ejemplo de como ejecutar un comando contra la base de datos
    // El comando es una sentencia DDL que crea la tabla equipo

    private static void createTableEquipo() {
        Connection conn = null;
        try {
            // El DriverManager proporciona el objeto Connection a partir de la URL
            // Para ello busca entre los Drivers registrados aquel que puede establecer una conexión
            // basándose en la URL protocolo:driver:propiedades
            conn = DriverManager.getConnection(HSQLDB_FUTBOL_URL, "SA", "");

            Statement stmt = null;
            try {
                // Usando el objeto Connection se crea un objeto Statement para enviar comandos SQL
                // sin parametros al RDBMS
                stmt = conn.createStatement();

                // El comando SQL es un String
                final String SQL_CREATE_TABLE_EQUIPO = """                                              
                        CREATE TABLE Equipo(
                        equipoID INTEGER IDENTITY PRIMARY KEY,
                        nombre VARCHAR(35) NOT NULL,
                        pais CHAR(3) NOT NULL)
                        """;
                try {
                    // Ejecuta el comando SQL
                    // Devuelve TRUE si el comando devuelve un ResultSet (SELECT)
                    stmt.execute(SQL_CREATE_TABLE_EQUIPO);
                    System.out.println("La tabla EQUIPO se ha creado.");

                } catch (SQLException e) {  //Al llamar a execute
                    System.out.println("ERROR al ejecutar el comando:");
                    System.out.println(e.getMessage());
                }

            } catch (SQLException e) { // Al llamar a createStatement
                System.out.println("ERROR al crear el comando:");
                System.out.println(e.getMessage());
            } finally { // Si se ha creado el statement entonces hay que cerrarlo
                if (stmt != null) {
                    stmt.close();
                    System.out.println("Statement cerrado. Recursos mantenidos por el comando liberados.");
                }
            }

        } catch (SQLException e) {  // Al obtener la conexión a la BBDD
            System.out.println("ERROR obteniendo la conexión a la base de datos");
            System.out.println(e.getMessage());

        } finally { // Si se ha obtenido una conexión hay que cerrarla para liberar el recurso
            if (conn != null) {
                try {
                    conn.close();
                    System.out.println("Conexion con la base de datos cerrada.");
                } catch (SQLException e) { // Al cerrar la conexion
                    System.out.println("ERROR CERRANDO LA CONEXION");
                    System.out.println(e.getMessage());
                }
            }
        }
    }

    // Este ejemplo también ejecuta un comando contra la base de datos
    // El comando es DDL para hacer un CREATE TABLE y crear la tabla jugador
    // En este caso vamos a utilizar un bloque try-with-resources para la conexión y el statement
    // De este modo no será necesario cerrarlos explícitamente en un bloque finally

    private static void createTableJugador() {

        try (Connection conn = DriverManager.getConnection(HSQLDB_FUTBOL_URL, "SA", "")) {
            try (Statement stmt = conn.createStatement()) {
                try {
                    final String SQL_CREATE_TABLE_JUGADOR = """                                              
                            CREATE TABLE jugador (
                                jugadorID INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 1) PRIMARY KEY,
                                nombre VARCHAR(30) NOT NULL,
                                pais CHAR(3) NOT NULL,
                                nacimiento DATE,
                                estatura DECIMAL(3,2),
                                peso INTEGER,
                                dorsal INTEGER,
                                equipoID INTEGER REFERENCES equipo)
                            """;
                    stmt.execute(SQL_CREATE_TABLE_JUGADOR);
                    System.out.println("La tabla jugador se ha creado.");

                } catch (SQLException e) { // Al llamar a execute
                    System.out.println("ERROR al ejecutar el comando:");
                    System.out.println(e.getMessage());
                }
            } catch (SQLException e) { // Al llamar a createStatement
                System.out.println("ERROR al crear el comando:");
                System.out.println(e.getMessage());
            }
        } catch (SQLException e) { // Al llamar a getConnection
            System.out.println("ERROR obteniendo la conexión a la base de datos");
            System.out.println(e.getMessage());
        }
    }

    // Otro ejemplo de ejecución de un comando SQL sin parámetros
    // Ahora el comando es una sentencia DML para insertar un equipo en la tabla EQUIPOS

    private static void insertEquipo() {
        try (Connection conn = DriverManager.getConnection(HSQLDB_FUTBOL_URL, "SA", "")) {
            try (Statement stmt = conn.createStatement()) {
                final String SQL_INSERT_EQUIPO = """
                        INSERT INTO equipo VALUES(1,'Real Madrid C.F.','ESP')
                        """;
                try {
                    stmt.execute(SQL_INSERT_EQUIPO);
                    System.out.println("Equipo insertado");

                } catch (SQLException e) {
                    System.out.println("ERROR al ejecutar el comando");
                    System.out.println(e.getMessage());
                }

            } catch (SQLException e) {
                System.out.println("ERROR al crear el comando");
                System.out.println(e.getMessage());
            }

        } catch (SQLException e) {
            System.out.println("ERROR al conectar a la BBDD");
            System.out.println(e.getMessage());
        }
    }

    // Ejemplo de ejecución de un comando SQL pasado con argumento de entrada
    // Como hemos visto en los ejemplos anteriores, podemos parametrizar el método
    // para que ejecute cualquier comando SQL proporcionado como parámetro de entrada
    // Vamos a devolver true si el comando se ha podido ejecutar con éxito
    // para informar al llamador del resultado
    private static boolean executeStatement(final String sql) {

        try (Connection conn = DriverManager.getConnection(HSQLDB_FUTBOL_URL, "SA", "")) {
            try (Statement stmt = conn.createStatement()) {

                try {
                    stmt.execute(sql);  // Ejecutamos el comando SQL
                    return true;

                } catch (SQLException e) {
                    System.out.println("ERROR al ejecutar el comando");
                    System.out.println(e.getMessage());
                }

            } catch (SQLException e) {
                System.out.println("ERROR al crear el comando");
                System.out.println(e.getMessage());
            }

        } catch (SQLException e) {
            System.out.println("ERROR al conectar a la BBDD");
            System.out.println(e.getMessage());
        }
        return false;
    }

    // Prueba del método executeStatement
    // El método insertJugador delega en el método executeStament
    // pasándole el String con el comando SQL para insertar un jugador
    private static void insertJugador() {
        if (executeStatement("""
                INSERT INTO Jugador
                VALUES (1,'Luka Modric','HSV','1985-09-09', 1.72, 66, 10, 1)
                """)) {
            System.out.println("Jugador insertado");
        }
    }

    // Ahora vamos a generar el comando SQL a partir de los parámetros de entrada
    // Dado que ejecutamos comandos SQL sin parámetros
    // Debemos componer el String con el comando SQL mediante operaciones con Strings
    // Tenemos que encerrar los valores de texto entre comillas simples
    private static void insertEquipo(int equipoId, String nombre, String pais) {
        String sql = "INSERT INTO equipo VALUES (" +
                     equipoId + ", " +
                     "'" + nombre + "', " +
                     "'" + pais + "')";

        if (executeStatement(sql)) {
            System.out.println("Equipo " + nombre + " insertado");
        }
    }


    // En este ejemplo vamos a dejar que el RDBMS genere el valor del campo IDENTITY (auto-numérico)

    // Un problema que tenemos al componer el comando SQL es que alguna variable String
    // como por ejemplo la variable nombre contenga el carácter ' (comilla simple)
    // Para escaparlo tendríamos que escribir ''' (tres comillas seguidas
    // Por ejemplo, si nombre fuera Club Atlético Newell's Old Boys
    // El comando fallaría si no codificamos el nombre como: Club Atlético Newell'''s Old Boys
    // Para codificar esto se usa el método enquoteLiteral(String) de la clase Statement
    private static void insertEquipo(String nombre, String pais) {
        try (Connection conn = DriverManager.getConnection(HSQLDB_FUTBOL_URL)) {
            try (Statement stmt = conn.createStatement()) {
                try {
                    String sql = "INSERT INTO equipo VALUES (DEFAULT, " +
                                 stmt.enquoteLiteral(nombre) + ", " +
                                 stmt.enquoteLiteral(pais) + ")";

                    // Para que cuando se ejecute el comando se nos devuelva el valor IDENTITY
                    // asignado como clave primaria al campo equipoID
                    // Utilizamos una versión sobrecargada del método execute
                    // El segundo parámetro es una constante int
                    stmt.execute(sql, Statement.RETURN_GENERATED_KEYS);

                    // El método getGenetatedKeys devuelve la clave auto-generada al ejecutar
                    // el comando SQL en un ResultSet
                    try(ResultSet generatedKeys = stmt.getGeneratedKeys()) {
                        if(generatedKeys.next()) { // Posicionar el cursor en la primera fila de resultados
                            int equipoId = generatedKeys.getInt(1); // Obtener el valor de la primera columna
                            System.out.println("Equipo " + nombre + " insertado con ID=" + equipoId);
                        }
                        generatedKeys.close(); // NO es necesario por el try-with-resources
                    } catch (SQLException e) {
                        System.out.println("ERROR obteniendo el ID autogenerado");
                        System.out.println(e.getMessage());
                    }

                } catch (SQLException e) {
                    System.out.println("ERROR ejecutando el comando");
                    System.out.println(e.getMessage());
                }
            } catch (SQLException e) {
                System.out.println("ERROR creando el comando");
                System.out.println(e.getMessage());
            }

        } catch (SQLException e) {
            System.out.println("ERROR conectando a la base de datos");
            System.out.println(e.getMessage());
        }
    }

    // En este ejemplo vamos a componer el comando haciendo uso de un objeto StringJoiner
    // Además, como se trata de un DML INSERT vamos a usar executeUpdate
    // en lugar del genérico execute para asi obtener un entero
    // que indica el número de filas que se han insertado / modificado / borrado

    private static boolean insertJugador(int jugadorId,
                                         String nombre,
                                         String pais,
                                         LocalDate nacimiento,
                                         double estatura,
                                         int peso,
                                         int dorsal,
                                         int equipoId) {
        try (Connection connection = DriverManager.getConnection(HSQLDB_FUTBOL_URL)) {

            try (Statement stmt = connection.createStatement()) {

                String sql = new StringJoiner(",", "INSERT INTO jugador VALUES (", ")")
                        .add(Integer.toString(jugadorId))
                        .add(stmt.enquoteLiteral(nombre))
                        .add(stmt.enquoteLiteral(pais))
                        .add("{d " + stmt.enquoteLiteral(nacimiento.toString()) + "}")
                        .add(Double.toString(estatura))
                        .add(Integer.toString(peso))
                        .add(Integer.toString(dorsal))
                        .add(Integer.toString(equipoId))
                        .toString();

                try {
                    int result = stmt.executeUpdate(sql);
                    System.out.println("Jugador " + nombre + " insertado");
                    return result != 0;

                } catch (SQLException ex) {
                    System.out.println("ERROR ejecutando el comando");
                    System.out.println(ex.getMessage());
                }

            } catch (SQLException e) {
                System.out.println("ERROR creando el comando");
                throw new RuntimeException(e);
            }
        } catch (SQLException e) {
            System.out.println("ERROR de conexión a la base de datos");
            System.out.println(e.getMessage());
        }
        return false;
    }

    // Em esta version de insertJugador no se proporciona ID de jugador
    // Dejamos que la BBDD genere un valor automático para ese campo
    private static boolean insertJugador(String nombre,
                                         String pais,
                                         LocalDate nacimiento,
                                         double estatura,
                                         int peso,
                                         int dorsal,
                                         int equipoId) {
        try (Connection connection = DriverManager.getConnection(HSQLDB_FUTBOL_URL)) {

            try (Statement stmt = connection.createStatement()) {

                String sql = new StringJoiner(",", "INSERT INTO jugador VALUES (DEFAULT, ", ")")
                        .add(stmt.enquoteLiteral(nombre))
                        .add(stmt.enquoteLiteral(pais))
                        .add("{d " + stmt.enquoteLiteral(nacimiento.toString()) + "}")
                        .add(Double.toString(estatura))
                        .add(Integer.toString(peso))
                        .add(Integer.toString(dorsal))
                        .add(Integer.toString(equipoId))
                        .toString();

                try {
                    int result = stmt.executeUpdate(sql);
                    System.out.println("Jugador " + nombre + " insertado");
                    return result != 0;

                } catch (SQLException ex) {
                    System.out.println("ERROR ejecutando el comando");
                    System.out.println(ex.getMessage());
                }

            } catch (SQLException e) {
                System.out.println("ERROR creando el comando");
                throw new RuntimeException(e);
            }
        } catch (SQLException e) {
            System.out.println("ERROR de conexión a la base de datos");
            System.out.println(e.getMessage());
        }
        return false;
    }

    // En este ejemplo recuperamos e imprimimos todos los equipos (SELECT * FROM equipo)
    // Sabemos cuando la ejecución de un Statement devuelve un ResultSet
    // porque el método execute devuelve un valor true
    // Un ResultSet en objeto para recorrer fila a fila
    // Y obtener los valores de los campos de la fila actual
    static void printAllEquipos() {
        try (Connection conn = DriverManager.getConnection(HSQLDB_FUTBOL_URL)) {
            try (Statement stmt = conn.createStatement()) {
                try {
                    String sql = "SELECT * FROM equipo";
                    if (stmt.execute(sql)) { // True si devuelve un ResultSet
                        final String format = "     %3s %-35s %-4s\n";
                        System.out.printf(format, "ID", "NOMBRE", "PAIS");

                        ResultSet rs = stmt.getResultSet();
                        while (rs.next()) { // Iteramos fila a fila moviendo el cursor
                            // Valor de la primera columna de la fila actual como int
                            int equipoId = rs.getInt(1);
                            // Valor de la segunda columna de la fila actual como String
                            String nombre = rs.getString(2);
                            // Valor de la tercera columna de la fila actual como String
                            String pais = rs.getString(3);

                            System.out.printf("%4s %3s %-35s %-4s\n", rs.getRow(), equipoId, nombre, pais);
                        }
                        rs.close();
                    }

                } catch (SQLException e) {
                    System.out.println("ERROR ejecutando el comando");
                    System.out.println(e.getMessage());
                }
            } catch (SQLException e) {
                System.out.println("ERROR creando el comando");
                System.out.println(e.getMessage());
            }

        } catch (SQLException e) {
            System.out.println("ERROR conectando a la base de datos");
            System.out.println(e.getMessage());
        }
    }

    // Ahora imprimimos los jugadores
    // Esta vez usamos el método executeQuery de la clase Statement
    // Este método se diferencia del execute en que ya devuelve directamente el ResultSet
    static void printAllJugadores() {
        try (Connection conn = DriverManager.getConnection(HSQLDB_FUTBOL_URL)) {
            try (Statement stmt = conn.createStatement()) {
                try {
                    String sql = "SELECT * FROM jugador";
                    // El metodo executeQuery ya devuelve directamente el ResultSet
                    ResultSet rs = stmt.executeQuery(sql);
                    final String format = "%3s %-30s %-4s %10s %8s %4s %6s\n";
                    System.out.printf(format, "ID", "NOMBRE", "PAIS", "NACIMIENTO", "ESTATURA", "PESO", "DORSAL");


                    while (rs.next()) { // Iteramos fila a fila moviendo el cursor
                        // Valor de la primera columna de la fila actual como int
                        int equipoId = rs.getInt(1);
                        // Valor de la segunda columna de la fila actual como String
                        String nombre = rs.getString(2);
                        // Valor de la tercera columna de la fila actual como String
                        String pais = rs.getString(3);
                        // Valor de la comuna con nombre 'nacimiento'
                        LocalDate nacimiento = rs.getObject("nacimiento", LocalDate.class);
                        // Valor de la columna con nombre 'estatura' como double
                        double estatura = rs.getDouble("estatura");
                        // Valor de la columna peso como int
                        int peso = rs.getInt("peso");
                        // Valor de columna dorsal como int
                        int dorsal = rs.getInt("dorsal");

                        System.out.printf(format, equipoId, nombre, pais, nacimiento.toString(), estatura, peso, dorsal);
                    }
                    rs.close();

                } catch (SQLException e) {
                    System.out.println("ERROR ejecutando el comando");
                    System.out.println(e.getMessage());
                }
            } catch (SQLException e) {
                System.out.println("ERROR creando el comando");
                System.out.println(e.getMessage());
            }

        } catch (SQLException e) {
            System.out.println("ERROR conectando a la base de datos");
            System.out.println(e.getMessage());
        }
    }

    private static void deleteAllJugadores() {
        executeStatement("DELETE FROM jugador");
    }

    private static void deleteAllEquipos() {
        executeStatement("DELETE FROM equipo");
    }

    private static void dropTable(String tableName) {
        executeStatement("DROP TABLE " + tableName);
    }

    private static void shutdown() {
        executeStatement("SHUTDOWN");
    }

}
